<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Interactive Model</title>
    <style>
        /* This removes all borders and scrollbars */
        body,
        html {
            margin: 0;
            padding: 0;
            overflow: hidden;
            width: 100%;
            height: 100%;
            background: transparent;
            /* This is the transparent background */
        }

        canvas {
            display: block;
        }
    </style>
</head>

<body>
    <script type="importmap">
    {
        "imports": {
            "three": "https://unpkg.com/three@0.166.1/build/three.module.js",
            "three/addons/": "https://unpkg.com/three@0.166.1/examples/jsm/"
        }
    }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';

        // --- 1. CONFIGURATION: EDIT THESE VALUES ---

        // IMPORTANT: Put your .glb file online and paste the URL here.
        const MODEL_URL = "Gkmodel.glb";

        // --- Bone Names (Check your Avaturn model!) ---
        const HEAD_BONE_NAME = "Head";      // Avaturn default
        const SPINE_BONE_NAME = "Spine2";   // Avaturn default

        // --- Look At Strength ---
        const MAX_YAW_ANGLE = 45;    // Max degrees left/right
        const MAX_PITCH_ANGLE = 20;  // Max degrees up/down
        const SMOOTHING = 0.05;      // How fast the head follows (0.01 = slow, 0.1 = fast)

        // --- Spine Influence (how much the spine moves with the head) ---
        const SPINE_YAW_INFLUENCE = 0.3;   // 30% of left/right
        const SPINE_PITCH_INFLUENCE = 0.5; // 50% of up/down

        // --- Model Position & Scale ---
        const MODEL_SCALE = 1.8;
        const MODEL_POS_Y = -1; // Move model down to ground it (adjust as needed)

        // --- NEW: Camera Intro Transition ---
        const CAMERA_TRANSITION_DURATION = 8; // Duration in seconds

        // Start Position (Closer)
        const START_CAM_X = 0;
        const START_CAM_Y = 2.1;
        const START_CAM_Z = 1.5;

        // End Position (Final)
        const END_CAM_X = 0;
        const END_CAM_Y = 1.4;
        const END_CAM_Z = 2.5;
        // ---------------------------------------------

        let scene, camera, renderer, headBone, spineBone, mixer, clock;
        let mousePos = new THREE.Vector2();

        // --- NEW: Camera transition variables ---
        let transitionTimer = 0.0;
        const startCamPos = new THREE.Vector3(START_CAM_X, START_CAM_Y, START_CAM_Z);
        const endCamPos = new THREE.Vector3(END_CAM_X, END_CAM_Y, END_CAM_Z);


        // 1. Setup the Scene
        scene = new THREE.Scene();
        clock = new THREE.Clock(); // For animations
        camera = new THREE.PerspectiveCamera(50, window.innerWidth / window.innerHeight, 0.1, 1000);

        // **MODIFIED:** Set camera to the start position
        camera.position.copy(startCamPos);

        renderer = new THREE.WebGLRenderer({
            antialias: true,
            alpha: true // This allows for a transparent background
        });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(window.devicePixelRatio);
        document.body.appendChild(renderer.domElement);

        // 2. Add Lights
        const ambientLight = new THREE.AmbientLight(0xffffff, 1.5);
        scene.add(ambientLight);
        const directionalLight = new THREE.DirectionalLight(0xffffff, 1.5);
        directionalLight.position.set(5, 5, 5);
        scene.add(directionalLight);

        // 3. Load the Model
        const loader = new GLTFLoader();
        loader.load(MODEL_URL, (gltf) => {
            gltf.scene.scale.set(MODEL_SCALE, MODEL_SCALE, MODEL_SCALE);
            gltf.scene.position.set(0, MODEL_POS_Y, 0);
            scene.add(gltf.scene);

            // --- Find the bones ---
            headBone = gltf.scene.getObjectByName(HEAD_BONE_NAME);
            spineBone = gltf.scene.getObjectByName(SPINE_BONE_NAME);

            if (!headBone) console.error(`Error: Could not find bone named "${HEAD_BONE_NAME}"`);
            if (!spineBone) console.warn(`Warning: Could not find bone named "${SPINE_BONE_NAME}"`);

            // --- Setup Animation ---
            if (gltf.animations.length > 0) {
                mixer = new THREE.AnimationMixer(gltf.scene);
                const action = mixer.clipAction(gltf.animations[0]);
                action.play();
            } else {
                console.warn("Model has no animations to play.");
            }

        }, undefined, (error) => {
            console.error(error);
        });

        // 4. Track Mouse Movement
        function onMouseMove(event) {
            // Convert mouse position to normalized device coordinates (-1 to +1)
            mousePos.x = (event.clientX / window.innerWidth) * 2 - 1;
            mousePos.y = -(event.clientY / window.innerHeight) * 2 + 1;
        }
        window.addEventListener('mousemove', onMouseMove);

        // 5. The Render Loop (runs every frame)
        function animate() {
            requestAnimationFrame(animate);
            const delta = clock.getDelta(); // Get time since last frame

            // --- NEW: Camera Transition Logic ---
            // This runs for the first 2.5 seconds (or whatever DURATION is)
            if (transitionTimer < CAMERA_TRANSITION_DURATION) {
                transitionTimer += delta;
                let progress = Math.min(transitionTimer / CAMERA_TRANSITION_DURATION, 1.0);

                // Add a smooth ease-out (cubic)
                let easedProgress = progress < 0.5
                ? 4 * progress * progress * progress
                : 1 - Math.pow(-2 * progress + 2, 3) / 2;

                camera.position.lerpVectors(startCamPos, endCamPos, easedProgress);
            }
            // --- End Camera Transition ---


            // Calculate target rotation in radians
            const targetYaw = mousePos.x * THREE.MathUtils.degToRad(MAX_YAW_ANGLE);
            const targetPitch = -mousePos.y * THREE.MathUtils.degToRad(MAX_PITCH_ANGLE); // Inverted Y

            // --- Apply rotations with smoothing (Lerp) ---
            if (headBone) {
                headBone.rotation.y = THREE.MathUtils.lerp(headBone.rotation.y, targetYaw, SMOOTHING);
                headBone.rotation.x = THREE.MathUtils.lerp(headBone.rotation.x, targetPitch, SMOOTHING);
            }

            if (spineBone) {
                spineBone.rotation.y = THREE.MathUtils.lerp(spineBone.rotation.y, targetYaw * SPINE_YAW_INFLUENCE, SMOOTHING);
                spineBone.rotation.x = THREE.MathUtils.lerp(spineBone.rotation.x, targetPitch * SPINE_PITCH_INFLUENCE, SMOOTHING);
            }

            // Update the animation mixer
            if (mixer) {
                mixer.update(delta);
            }

            renderer.render(scene, camera);
        }

        // Handle window resizing
        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }
        window.addEventListener('resize', onWindowResize);

        // Start the loop!
        animate();
    </script>
</body>

</html>
