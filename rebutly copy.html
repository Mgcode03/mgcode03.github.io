<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>YAWP | Feel Loud</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css" rel="stylesheet">
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Anton&family=Space+Grotesk:wght@400;500;700&display=swap"
        rel="stylesheet">

    <script>
        tailwind.config = {
            theme: {
                extend: {
                    colors: {
                        'yawp-red': '#E61919',
                        'yawp-black': '#111111',
                        'yawp-white': '#FFFFFF',
                        'yawp-offwhite': '#F4F4F4',
                        'yawp-blue': '#0047AB',
                    },
                    fontFamily: {
                        'display': ['Anton', 'sans-serif'],
                        'body': ['Space Grotesk', 'sans-serif'],
                    },
                    animation: {
                        'shake-hard': 'shake 0.5s cubic-bezier(.36,.07,.19,.97) both',
                        'marquee': 'marquee 25s linear infinite',
                    },
                    keyframes: {
                        shake: {
                            '10%, 90%': { transform: 'translate3d(-2px, 0, 0)' },
                            '20%, 80%': { transform: 'translate3d(4px, 0, 0)' },
                            '30%, 50%, 70%': { transform: 'translate3d(-6px, 0, 0)' },
                            '40%, 60%': { transform: 'translate3d(6px, 0, 0)' }
                        },
                        marquee: {
                            '0%': { transform: 'translateX(0%)' },
                            '100%': { transform: 'translateX(-100%)' },
                        }
                    }
                }
            }
        }
    </script>
    <style>
        body {
            background-color: #FFFFFF;
            color: #111111;
            overflow: hidden;
            touch-action: none;
            font-family: 'Space Grotesk', sans-serif;
        }

        /* Neo-Brutalist Components */
        .brutalist-btn {
            background: #FFFFFF;
            border: 3px solid #000000;
            color: #000000;
            font-weight: 700;
            text-transform: uppercase;
            box-shadow: 4px 4px 0px 0px #000000;
            transition: all 0.1s cubic-bezier(0, 0, 0.2, 1);
            white-space: nowrap;
        }

        .brutalist-btn:hover {
            transform: translate(-2px, -2px);
            box-shadow: 6px 6px 0px 0px #000000;
            background: #E61919;
            color: #FFFFFF;
            border-color: #000000;
        }

        .brutalist-btn:active {
            transform: translate(2px, 2px);
            box-shadow: 0px 0px 0px 0px #000000;
        }

        .brutalist-btn.active {
            background: #E61919;
            color: #FFFFFF;
            box-shadow: inset 4px 4px 0px 0px rgba(0, 0, 0, 0.5);
            transform: translate(2px, 2px);
        }

        .brutalist-panel {
            border: 4px solid black;
            box-shadow: 8px 8px 0px 0px #E61919;
            background: white;
        }

        /* Mode & Layout */
        .mode-container {
            display: none;
            height: 100vh;
            width: 100vw;
            position: absolute;
            top: 0;
            left: 0;
            flex-direction: column;
        }

        .mode-container.active {
            display: flex;
        }

        canvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 10;
        }

        /* Tool Specifics */
        .instruction-tag {
            position: absolute;
            top: 100px;
            left: 50%;
            transform: translateX(-50%) rotate(-1deg);
            background: #E61919;
            color: white;
            border: 3px solid #000000;
            padding: 8px 24px;
            z-index: 50;
            font-family: 'Space Grotesk', sans-serif;
            text-transform: uppercase;
            font-weight: 700;
            font-size: 1rem;
            box-shadow: 4px 4px 0px #000000;
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.3s ease;
        }

        .mode-container.active .instruction-tag {
            opacity: 1;
            animation: slideDown 0.6s cubic-bezier(0.175, 0.885, 0.32, 1.275) forwards;
        }

        @keyframes slideDown {
            from {
                transform: translate(-50%, -150%) rotate(5deg);
                opacity: 0;
            }

            to {
                transform: translate(-50%, 0) rotate(-1deg);
                opacity: 1;
            }
        }

        .screamed-word {
            position: absolute;
            font-family: 'Anton', sans-serif;
            font-weight: 400;
            text-transform: uppercase;
            white-space: nowrap;
            -webkit-text-stroke: 1.5px black;
            pointer-events: none;
        }

        #about-modal {
            transition: transform 0.4s cubic-bezier(0.175, 0.885, 0.32, 1.275);
        }

        #about-modal.hidden-modal {
            transform: translate(100%, 0);
        }

        #about-modal.visible-modal {
            transform: translate(0, 0);
        }

        /* Microphone Pulse */
        .mic-pulse {
            animation: micPulse 1.5s infinite;
        }

        @keyframes micPulse {
            0% {
                box-shadow: 0 0 0 0 rgba(230, 25, 25, 0.7);
            }

            70% {
                box-shadow: 0 0 0 20px rgba(230, 25, 25, 0);
            }

            100% {
                box-shadow: 0 0 0 0 rgba(230, 25, 25, 0);
            }
        }

        .color-btn {
            width: 2.5rem;
            height: 2.5rem;
            border: 2px solid black;
            transition: transform 0.1s;
            box-shadow: 2px 2px 0px 0px rgba(0, 0, 0, 1);
        }

        .color-btn:hover {
            transform: scale(1.1);
        }
    </style>
</head>

<body>

    <!-- Main Navigation -->
    <nav
        class="fixed top-0 left-0 w-full z-50 bg-white border-b-4 border-black p-0 flex justify-between items-stretch h-20 select-none">
        <div class="flex items-center px-6 bg-white border-r-4 border-black cursor-pointer hover:bg-yawp-offwhite transition-colors group"
            onclick="switchMode('home')">
            <div class="flex flex-col leading-none">
                <span
                    class="text-4xl font-display text-yawp-red tracking-tight group-hover:scale-105 transition-transform">YAWP</span>
            </div>
            <i class="fas fa-bolt text-2xl ml-3 text-black"></i>
        </div>

        <div
            class="flex-grow flex items-center justify-start md:justify-end px-4 gap-3 overflow-x-auto bg-white no-scrollbar">
            <button onclick="switchMode('scream')" id="btn-scream"
                class="brutalist-btn px-4 py-2 text-sm tracking-wide">Scream</button>
            <button onclick="switchMode('splatter')" id="btn-splatter"
                class="brutalist-btn px-4 py-2 text-sm tracking-wide">Splatter</button>
            <button onclick="switchMode('break')" id="btn-break"
                class="brutalist-btn px-4 py-2 text-sm tracking-wide">Break</button>
            <button onclick="switchMode('dummy')" id="btn-dummy"
                class="brutalist-btn px-4 py-2 text-sm tracking-wide">Dummy</button>
            <button onclick="switchMode('punch')" id="btn-punch"
                class="brutalist-btn px-4 py-2 text-sm tracking-wide bg-black text-white border-black">Punch</button>
            <button onclick="switchMode('shout')" id="btn-shout"
                class="brutalist-btn px-4 py-2 text-sm tracking-wide text-yawp-red border-yawp-red"><i
                    class="fas fa-microphone mr-2"></i>Shout</button>
            <button onclick="switchMode('mirror')" id="btn-mirror"
                class="brutalist-btn px-4 py-2 text-sm tracking-wide"><i class="fas fa-camera mr-2"></i>Mirror</button>
            <button onclick="toggleAbout()" class="ml-4 brutalist-btn px-3 py-2 text-sm bg-gray-200"><i
                    class="fas fa-info"></i></button>
        </div>
    </nav>

    <!-- ABOUT MODAL (Updated) -->
    <div id="about-modal"
        class="hidden-modal fixed top-20 right-0 w-full md:w-1/2 lg:w-1/3 h-[calc(100vh-80px)] bg-white border-l-4 border-black z-[60] p-8 overflow-y-auto shadow-[-10px_0px_20px_rgba(0,0,0,0.1)]">
        <h2 class="font-display text-6xl mb-4 text-yawp-red">MANIFESTO</h2>
        <div class="h-2 bg-black w-full mb-8"></div>

        <div class="space-y-8">
            <section>
                <h3 class="font-display text-3xl mb-2">WHAT IS YAWP?</h3>
                <p class="font-body text-lg leading-relaxed border-l-4 border-yawp-red pl-4">
                    YAWP is a digital sanctuary for the loud, the messy, and the chaotic. We reject the idea that
                    wellness must be quiet. Sometimes, healing sounds like breaking glass or screaming into the void.
                    This is your safe space to externalize what you've been suppressing.
                </p>
            </section>

            <section>
                <h3 class="font-display text-3xl mb-2">OUR VISION</h3>
                <p class="font-body text-lg">
                    To redefine emotional release for the digital age, creating a world where "feeling loud" is seen as
                    a strength, not a disturbance.
                </p>
            </section>

            <section>
                <h3 class="font-display text-3xl mb-2">OUR MISSION</h3>
                <p class="font-body text-lg">
                    We provide interactive, kinetic tools that allow users to physically and visually process strong
                    emotions—Anger, Anxiety, Grief, and Joy—without judgment or consequence.
                </p>
            </section>

            <section>
                <h3 class="font-display text-3xl mb-2">SERVICES</h3>
                <ul class="list-disc pl-5 font-body text-lg space-y-1 font-bold">
                    <li>Interactive Catharsis Tools</li>
                    <li>Digital Rage Rooms</li>
                    <li>Somatic Web Experiences</li>
                    <li>Virtual Safe Spaces</li>
                </ul>
            </section>

            <section>
                <h3 class="font-display text-3xl mb-2">CONTACT</h3>
                <div class="bg-gray-100 p-4 border-2 border-black">
                    <p class="font-body font-bold">General Inquiries:</p>
                    <p class="font-body mb-2 text-yawp-red">hello@yawp.release</p>
                    <p class="font-body font-bold">Collaborations:</p>
                    <p class="font-body text-yawp-red">partners@yawp.release</p>
                </div>
            </section>
        </div>

        <button onclick="toggleAbout()"
            class="brutalist-btn w-full py-4 text-xl mt-8 bg-black text-white hover:bg-gray-800">CLOSE
            MANIFESTO</button>
    </div>

    <!-- MODE 1: HOME -->
    <div id="home" class="mode-container active justify-center items-center bg-white relative z-30 overflow-hidden">
        <div class="absolute inset-0 z-0 opacity-5"
            style="background-image: radial-gradient(#000 2px, transparent 2px); background-size: 20px 20px;"></div>

        <!-- Background Marquee -->
        <div
            class="absolute top-1/2 left-0 w-full bg-yawp-red border-y-4 border-black transform -rotate-6 -translate-y-1/2 py-2 z-0 overflow-hidden pointer-events-none">
            <div
                class="animate-marquee whitespace-nowrap font-display text-5xl md:text-8xl text-white tracking-widest uppercase">
                DO NOT GO GENTLE • SOUND YOUR BARBARIC YAWP • BREAK THE PATTERN • RELEASE • DO NOT GO GENTLE • SOUND
                YOUR BARBARIC YAWP •
            </div>
        </div>

        <div class="brutalist-panel relative z-10 p-8 md:p-12 max-w-2xl w-full mx-4 text-center transform rotate-2">
            <h1 class="text-6xl md:text-8xl font-display text-black mb-2 uppercase leading-[0.9]">
                CATHARSIS<br><span class="text-yawp-red">ENGINE</span>
            </h1>
            <p class="text-lg md:text-xl font-body text-gray-800 font-bold mb-8 mt-4">
                A suite of digital destruction tools.
            </p>
            <div class="grid grid-cols-2 gap-4">
                <button onclick="switchMode('break')"
                    class="brutalist-btn py-4 text-xl bg-black text-white hover:bg-gray-900 shadow-[4px_4px_0px_0px_#E61919]">Start
                    Breaking</button>
                <button onclick="switchMode('shout')" class="brutalist-btn py-4 text-xl">Vocal Release</button>
            </div>
        </div>
    </div>

    <!-- MODE 2: THE SCREAM -->
    <div id="scream" class="mode-container justify-center items-center bg-white z-40">
        <div id="scream-ui" class="z-50 w-full max-w-4xl px-6 flex flex-col gap-6">
            <label
                class="text-black font-display text-3xl uppercase tracking-tight bg-white inline-block px-4 py-1 border-2 border-black shadow-[4px_4px_0px_0px_#E61919] w-max transform -rotate-1">
                Type your burden
            </label>
            <textarea id="scream-input" rows="1"
                class="w-full bg-transparent border-b-8 border-black text-black text-5xl md:text-8xl font-display outline-none placeholder-gray-200 resize-none py-4 uppercase leading-none transition-colors focus:border-yawp-red"
                placeholder="SCREAM HERE"></textarea>
            <div class="flex justify-end">
                <button onclick="triggerScream()"
                    class="brutalist-btn bg-yawp-red text-white border-black px-12 py-6 text-4xl hover:bg-black hover:border-black">EXPLODE</button>
            </div>
        </div>
        <div id="scream-words-container"></div>
    </div>

    <!-- MODE 3: SPLATTER -->
    <div id="splatter" class="mode-container bg-white cursor-crosshair">
        <canvas id="splatter-canvas"></canvas>
        <div
            class="absolute top-24 left-4 z-50 flex flex-col gap-3 bg-white border-4 border-black p-3 shadow-[4px_4px_0px_0px_#000]">
            <button onclick="setSplatterColor('#E61919')" class="color-btn bg-[#E61919]"></button>
            <button onclick="setSplatterColor('#000000')" class="color-btn bg-[#000000]"></button>
            <button onclick="setSplatterColor('#0047AB')" class="color-btn bg-[#0047AB]"></button>
            <button onclick="setSplatterColor('#CCFF00')" class="color-btn bg-[#CCFF00]"></button>
            <button onclick="setSplatterColor('#FF00FF')" class="color-btn bg-[#FF00FF]"></button>
            <button onclick="setSplatterColor('#FFD700')" class="color-btn bg-[#FFD700]"></button>

            <button onclick="clearSplatter()"
                class="mt-2 w-10 h-10 border-2 border-black bg-white text-black flex items-center justify-center font-bold text-lg hover:bg-gray-100 shadow-[2px_2px_0px_0px_rgba(0,0,0,1)]"><i
                    class="fas fa-trash"></i></button>
        </div>
        <div class="instruction-tag">Move fast for chaos.</div>
    </div>

    <!-- MODE 4: BREAK -->
    <div id="break" class="mode-container bg-white cursor-pointer select-none overflow-hidden">
        <canvas id="break-canvas"></canvas>
        <div id="break-overlay"
            class="pointer-events-none absolute top-1/2 left-1/2 transform -translate-x-1/2 -translate-y-1/2 z-0">
            <h2 class="text-[20vw] font-display text-gray-100 leading-none text-center select-none opacity-50">GLASS
            </h2>
        </div>
        <div class="instruction-tag">Tap to crack. Break it all.</div>
        <div
            class="absolute bottom-10 right-10 w-64 bg-white border-4 border-black p-2 z-50 shadow-[4px_4px_0px_0px_#000]">
            <div class="text-xs font-bold uppercase mb-1 flex justify-between"><span>Structural Integrity</span><span
                    id="integrity-val">100%</span></div>
            <div class="w-full h-4 border-2 border-black bg-gray-200">
                <div id="integrity-bar" class="h-full bg-black transition-all duration-100" style="width: 100%"></div>
            </div>
        </div>
    </div>

    <!-- MODE 5: DUMMY -->
    <div id="dummy" class="mode-container bg-gray-50 cursor-grab active:cursor-grabbing overflow-hidden">
        <canvas id="dummy-canvas"></canvas>
        <div class="instruction-tag">Drag & Smash Him.</div>
        <div class="absolute bottom-0 left-0 p-8 pointer-events-none opacity-20">
            <h2 class="font-display text-9xl text-black select-none">DUMMY</h2>
        </div>
    </div>

    <!-- MODE 6: PUNCH -->
    <div id="punch" class="mode-container bg-black overflow-hidden cursor-crosshair">
        <div class="absolute inset-0 flex items-center justify-center pointer-events-none">
            <div id="punch-bag"
                class="w-64 h-64 rounded-full border-8 border-white bg-yawp-red shadow-[0px_0px_50px_rgba(230,25,25,0.5)] flex items-center justify-center transition-transform">
                <i class="fas fa-fist-raised text-6xl text-black opacity-50"></i>
            </div>
        </div>
        <div class="instruction-tag">Click fast to punch.</div>
        <div class="absolute bottom-10 left-1/2 transform -translate-x-1/2 text-white font-display text-4xl">
            COMBO: <span id="punch-combo" class="text-yawp-red">0</span>
        </div>
    </div>

    <!-- MODE 7: SHOUT (Immersive Audio Reactive) -->
    <div id="shout" class="mode-container bg-black overflow-hidden">
        <canvas id="shout-canvas"></canvas>

        <!-- Immersive Overlay Info -->
        <div class="absolute top-24 right-4 z-50 flex flex-col gap-2 items-end">
            <div class="flex items-center gap-2 bg-black border-2 border-white px-3 py-1">
                <div id="mic-status-dot" class="w-3 h-3 rounded-full bg-gray-600"></div>
                <span id="mic-status-text" class="font-bold text-xs uppercase text-white">Mic Check</span>
            </div>
            <!-- Feedback Text -->
            <div id="heard-text" class="bg-white text-black px-2 py-1 font-body text-xs uppercase hidden">
                Heard: <span id="heard-value">...</span>
            </div>
        </div>

        <div class="instruction-tag bg-black text-white border-white">Scream to feed the void</div>

        <!-- Fallback Input -->
        <div id="shout-fallback"
            class="hidden absolute bottom-20 left-1/2 transform -translate-x-1/2 w-full max-w-xl px-4 z-[55]">
            <div class="bg-yellow-200 border-2 border-black p-2 mb-2 text-xs font-bold text-center">MICROPHONE NOT
                DETECTED - USE KEYBOARD</div>
            <input type="text" id="shout-input"
                class="w-full bg-white border-4 border-black p-4 font-display text-2xl uppercase text-center shadow-[4px_4px_0px_0px_#000]"
                placeholder="TYPE TO RELEASE" autocomplete="off">
        </div>

        <div
            class="absolute bottom-10 left-10 font-display text-6xl text-white pointer-events-none mix-blend-difference">
            RELEASED <span id="shout-score" class="text-yawp-red">0</span>
        </div>

        <div id="shout-gameover"
            class="hidden absolute inset-0 bg-black/95 z-[60] flex flex-col items-center justify-center text-white">
            <h2 class="font-display text-9xl text-yawp-red mb-4">SILENCE BROKEN</h2>
            <p class="font-body text-xl mb-8">You released <span id="shout-final-score">0</span> thoughts.</p>
            <button onclick="resetShout()"
                class="brutalist-btn bg-white text-black px-12 py-6 text-3xl hover:bg-yawp-red hover:text-white border-white">AGAIN</button>
        </div>
    </div>

    <!-- MODE 8: MIRROR (Flux Only) -->
    <div id="mirror" class="mode-container bg-black overflow-hidden relative">
        <video id="mirror-video" class="hidden" autoplay playsinline></video>
        <canvas id="mirror-canvas"></canvas>

        <div class="instruction-tag text-white bg-black border-white">Move to burn</div>

        <!-- Removed toggle buttons, Flux is now the only truth -->

        <div id="camera-error" class="hidden absolute inset-0 flex items-center justify-center bg-black z-[60]">
            <div class="text-center p-8 border-4 border-white">
                <h3 class="font-display text-4xl text-yawp-red mb-4">CAMERA BLOCKED</h3>
                <p class="text-white font-body">Allow camera access to enter the flux.</p>
            </div>
        </div>
    </div>

    <script>
        // --- GLOBAL & ROUTING ---
        let currentMode = 'home';
        let animationFrames = {};

        // Shout Tool Globals
        let shoutVolume = 0;
        let audioDataArray = [];
        let audioAnalyser = null;

        function switchMode(mode) {
            // Cleanup
            Object.values(animationFrames).forEach(id => cancelAnimationFrame(id));
            animationFrames = {};

            // Stop mic/cam if leaving specific modes
            if (currentMode === 'shout' && mode !== 'shout') stopShoutTools();
            if (currentMode === 'mirror' && mode !== 'mirror') stopMirrorTools();

            // UI State
            document.querySelectorAll('.mode-container').forEach(el => el.classList.remove('active'));
            document.querySelectorAll('.brutalist-btn').forEach(el => el.classList.remove('active'));

            // Activate
            const container = document.getElementById(mode);
            container.classList.add('active');

            if (mode !== 'home') {
                const btn = document.getElementById(`btn-${mode}`);
                if (btn) btn.classList.add('active');
            }

            currentMode = mode;

            // Initialize Tools
            if (mode === 'splatter') initSplatter();
            else if (mode === 'break') initBreak();
            else if (mode === 'dummy') initDummy();
            else if (mode === 'punch') initPunch();
            else if (mode === 'shout') initShout();
            else if (mode === 'mirror') initMirror();
            else if (mode === 'scream') document.getElementById('scream-input').focus();
        }

        function toggleAbout() {
            const modal = document.getElementById('about-modal');
            if (modal.classList.contains('hidden-modal')) {
                modal.classList.remove('hidden-modal');
                modal.classList.add('visible-modal');
            } else {
                modal.classList.add('hidden-modal');
                modal.classList.remove('visible-modal');
            }
        }

        function resizeCanvas(c) {
            c.width = window.innerWidth;
            c.height = window.innerHeight;
        }

        // --- TOOL: SCREAM ---
        const screamInput = document.getElementById('scream-input');
        const screamContainer = document.getElementById('scream-words-container');
        screamInput.addEventListener('keydown', (e) => { if (e.key === 'Enter') { e.preventDefault(); triggerScream(); } });

        function triggerScream() {
            const text = screamInput.value.trim();
            if (!text) return;
            document.body.classList.add('animate-shake-hard');
            setTimeout(() => document.body.classList.remove('animate-shake-hard'), 500);
            for (let i = 0; i < 12; i++) createScreamWord(text);
            screamInput.value = '';
        }

        function createScreamWord(text) {
            const el = document.createElement('div');
            el.innerText = text;
            el.classList.add('screamed-word');
            const size = Math.random() * 6 + 4;
            el.style.fontSize = `${size}rem`;
            el.style.color = Math.random() > 0.5 ? '#E61919' : (Math.random() > 0.5 ? 'black' : 'transparent');
            el.style.left = '50%'; el.style.top = '50%';
            screamContainer.appendChild(el);

            const angle = Math.random() * Math.PI * 2;
            const velocity = Math.random() * 800 + 200;
            const destX = Math.cos(angle) * velocity;
            const destY = Math.sin(angle) * velocity;

            requestAnimationFrame(() => {
                el.style.transition = 'all 0.8s cubic-bezier(0.1, 0.7, 1.0, 0.1)';
                el.style.transform = `translate(calc(-50% + ${destX}px), calc(-50% + ${destY}px)) rotate(${(Math.random() - 0.5) * 90}deg)`;
                el.style.opacity = '0';
            });
            setTimeout(() => el.remove(), 800);
        }

        // --- TOOL: SPLATTER ---
        let splatterCanvas, ctxSplatter, drips = [];
        let splatterColor = '#E61919';
        let isSplattering = false;
        let lastX = 0, lastY = 0;

        function initSplatter() {
            splatterCanvas = document.getElementById('splatter-canvas');
            ctxSplatter = splatterCanvas.getContext('2d');
            resizeCanvas(splatterCanvas);

            if (!splatterCanvas.hasBeenDrawn) {
                ctxSplatter.fillStyle = '#FFFFFF';
                ctxSplatter.fillRect(0, 0, splatterCanvas.width, splatterCanvas.height);
                splatterCanvas.hasBeenDrawn = true;
            }

            splatterCanvas.onmousedown = (e) => {
                isSplattering = true;
                lastX = e.clientX; lastY = e.clientY;
                addSplat(e);
            };
            splatterCanvas.onmousemove = (e) => { if (isSplattering) addSplat(e); };
            splatterCanvas.onmouseup = () => isSplattering = false;
            splatterCanvas.ontouchstart = (e) => {
                isSplattering = true;
                lastX = e.touches[0].clientX; lastY = e.touches[0].clientY;
                addSplat(e.touches[0]);
            };
            splatterCanvas.ontouchmove = (e) => { if (isSplattering) addSplat(e.touches[0]); };
            splatterCanvas.ontouchend = () => isSplattering = false;

            animateSplatter();
        }

        function setSplatterColor(c) { splatterColor = c; }
        function clearSplatter() {
            ctxSplatter.fillStyle = '#FFFFFF';
            ctxSplatter.fillRect(0, 0, splatterCanvas.width, splatterCanvas.height);
            drips = [];
        }

        function addSplat(e) {
            const rect = splatterCanvas.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;

            const dist = Math.sqrt(Math.pow(x - lastX, 2) + Math.pow(y - lastY, 2));
            const velocity = Math.min(dist, 50);

            lastX = x;
            lastY = y;

            ctxSplatter.fillStyle = splatterColor;
            const baseRadius = (Math.random() * 10 + 5) + (velocity * 0.5);

            ctxSplatter.beginPath();
            ctxSplatter.arc(x, y, baseRadius, 0, Math.PI * 2);
            ctxSplatter.fill();

            const scatterCount = Math.floor(Math.random() * 5) + Math.floor(velocity / 5);
            for (let i = 0; i < scatterCount; i++) {
                const range = 50 + velocity * 2;
                const dx = (Math.random() - 0.5) * range;
                const dy = (Math.random() - 0.5) * range;
                const r = Math.random() * (baseRadius / 3);

                ctxSplatter.beginPath();
                ctxSplatter.arc(x + dx, y + dy, r, 0, Math.PI * 2);
                ctxSplatter.fill();
            }

            if (Math.random() < 0.3) {
                drips.push({ x: x, y: y, color: splatterColor, speed: Math.random() * 2 + 1, life: Math.random() * 200 + 50 });
            }
        }

        function animateSplatter() {
            if (currentMode !== 'splatter') return;
            drips.forEach((d, i) => {
                if (d.life > 0) {
                    ctxSplatter.fillStyle = d.color;
                    ctxSplatter.beginPath();
                    ctxSplatter.arc(d.x, d.y, Math.random() * 2 + 1, 0, Math.PI * 2);
                    ctxSplatter.fill();
                    d.y += d.speed;
                    d.life--;
                } else {
                    drips.splice(i, 1);
                }
            });
            animationFrames['splatter'] = requestAnimationFrame(animateSplatter);
        }

        // --- TOOL: BREAK ---
        let breakCanvas, ctxBreak, shards = [], integrity = 100;

        function initBreak() {
            breakCanvas = document.getElementById('break-canvas');
            ctxBreak = breakCanvas.getContext('2d');
            resizeCanvas(breakCanvas);
            integrity = 100;
            shards = [];
            updateBreakUI();

            breakCanvas.onclick = crackScreen;
            animateBreak();
        }

        function crackScreen(e) {
            if (integrity <= 0) return;
            const rect = breakCanvas.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;

            ctxBreak.beginPath();
            ctxBreak.moveTo(x, y);
            let cx = x, cy = y;
            for (let i = 0; i < 8; i++) {
                cx += (Math.random() - 0.5) * 50;
                cy += (Math.random() - 0.5) * 50;
                ctxBreak.lineTo(cx, cy);
            }
            ctxBreak.strokeStyle = 'rgba(0,0,0,0.8)';
            ctxBreak.lineWidth = 2;
            ctxBreak.stroke();

            integrity -= 10;
            updateBreakUI();
            if (integrity <= 0) shatterScreen();
        }

        function updateBreakUI() {
            document.getElementById('integrity-bar').style.width = Math.max(0, integrity) + '%';
            document.getElementById('integrity-val').innerText = Math.max(0, integrity) + '%';
        }

        function shatterScreen() {
            ctxBreak.clearRect(0, 0, breakCanvas.width, breakCanvas.height);
            document.getElementById('break-overlay').style.display = 'none';

            const cols = 10; const rows = 10;
            const w = breakCanvas.width / cols;
            const h = breakCanvas.height / rows;

            for (let i = 0; i < cols; i++) {
                for (let j = 0; j < rows; j++) {
                    shards.push({
                        x: i * w + w / 2,
                        y: j * h + h / 2,
                        vx: (Math.random() - 0.5) * 20,
                        vy: (Math.random() - 0.5) * 20,
                        rot: 0,
                        vRot: (Math.random() - 0.5) * 0.5,
                        color: Math.random() > 0.5 ? '#E61919' : '#000000',
                        w: w * 0.8,
                        h: h * 0.8
                    });
                }
            }
            setTimeout(() => {
                integrity = 100;
                shards = [];
                updateBreakUI();
                document.getElementById('break-overlay').style.display = 'block';
            }, 3000);
        }

        function animateBreak() {
            if (currentMode !== 'break') return;
            if (shards.length > 0) {
                ctxBreak.clearRect(0, 0, breakCanvas.width, breakCanvas.height);
                shards.forEach(s => {
                    s.x += s.vx; s.y += s.vy; s.vy += 0.5; s.rot += s.vRot;
                    ctxBreak.save();
                    ctxBreak.translate(s.x, s.y);
                    ctxBreak.rotate(s.rot);
                    ctxBreak.fillStyle = s.color;
                    ctxBreak.fillRect(-s.w / 2, -s.h / 2, s.w, s.h);
                    ctxBreak.restore();
                });
            }
            animationFrames['break'] = requestAnimationFrame(animateBreak);
        }

        // --- TOOL: PUNCH ---
        let punchCombo = 0;
        function initPunch() {
            const container = document.getElementById('punch');
            const bag = document.getElementById('punch-bag');
            punchCombo = 0;
            document.getElementById('punch-combo').innerText = '0';

            container.onmousedown = (e) => {
                punchCombo++;
                document.getElementById('punch-combo').innerText = punchCombo;
                document.body.classList.add('animate-shake-hard');
                setTimeout(() => document.body.classList.remove('animate-shake-hard'), 200);

                const rect = bag.getBoundingClientRect();
                const dx = (e.clientX - (rect.left + rect.width / 2)) / 5;
                const dy = (e.clientY - (rect.top + rect.height / 2)) / 5;

                bag.style.transform = `translate(${-dx}px, ${-dy}px) scale(0.95)`;
                setTimeout(() => { bag.style.transform = `translate(0,0) scale(1)`; }, 100);
                createPunchParticle(e.clientX, e.clientY);
            };
        }

        function createPunchParticle(x, y) {
            const p = document.createElement('div');
            p.className = 'absolute w-12 h-12 bg-white rounded-full pointer-events-none opacity-50';
            p.style.left = x + 'px';
            p.style.top = y + 'px';
            p.style.transform = 'translate(-50%, -50%)';
            document.getElementById('punch').appendChild(p);

            const anim = p.animate([
                { transform: 'translate(-50%, -50%) scale(0.5)', opacity: 0.8 },
                { transform: 'translate(-50%, -50%) scale(3)', opacity: 0 }
            ], { duration: 300 });

            anim.onfinish = () => p.remove();
        }

        // --- TOOL: DUMMY ---
        let dummyCanvas, ctxDummy, points = [], sticks = [], draggingPoint = null;
        function initDummy() {
            dummyCanvas = document.getElementById('dummy-canvas');
            ctxDummy = dummyCanvas.getContext('2d');
            resizeCanvas(dummyCanvas);

            points = []; sticks = [];
            const startX = dummyCanvas.width / 2;
            const startY = 150;
            const p = (x, y) => points.push({ x, y, oldx: x, oldy: y, pinned: false });
            p(startX, startY); p(startX, startY + 40);
            p(startX - 30, startY + 40); p(startX + 30, startY + 40);
            p(startX - 20, startY + 120); p(startX + 20, startY + 120);
            p(startX - 50, startY + 80); p(startX - 70, startY + 110);
            p(startX + 50, startY + 80); p(startX + 70, startY + 110);
            p(startX - 25, startY + 180); p(startX - 30, startY + 240);
            p(startX + 25, startY + 180); p(startX + 30, startY + 240);

            const s = (i1, i2) => {
                const dx = points[i2].x - points[i1].x;
                const dy = points[i2].y - points[i1].y;
                sticks.push({ p0: points[i1], p1: points[i2], length: Math.sqrt(dx * dx + dy * dy) });
            };
            s(0, 1); s(1, 2); s(1, 3); s(2, 6); s(6, 7); s(3, 8); s(8, 9);
            s(1, 4); s(1, 5); s(4, 5); s(4, 10); s(10, 11); s(5, 12); s(12, 13);
            s(2, 4); s(3, 5);

            dummyCanvas.onmousedown = (e) => {
                const rect = dummyCanvas.getBoundingClientRect();
                const x = e.clientX - rect.left;
                const y = e.clientY - rect.top;
                let closest = null, dist = 50;
                points.forEach(p => {
                    const d = Math.sqrt((p.x - x) ** 2 + (p.y - y) ** 2);
                    if (d < dist) { dist = d; closest = p; }
                });
                if (closest) draggingPoint = closest;
            };

            window.onmousemove = (e) => {
                if (draggingPoint) {
                    const rect = dummyCanvas.getBoundingClientRect();
                    draggingPoint.x = e.clientX - rect.left;
                    draggingPoint.y = e.clientY - rect.top;
                    draggingPoint.oldx = draggingPoint.x - e.movementX * 1.5;
                    draggingPoint.oldy = draggingPoint.y - e.movementY * 1.5;
                }
            };
            window.onmouseup = () => draggingPoint = null;
            updateDummy();
        }

        function updateDummy() {
            if (currentMode !== 'dummy') return;
            ctxDummy.clearRect(0, 0, dummyCanvas.width, dummyCanvas.height);

            points.forEach(p => {
                if (!p.pinned && p !== draggingPoint) {
                    const vx = (p.x - p.oldx) * 0.99; const vy = (p.y - p.oldy) * 0.99;
                    p.oldx = p.x; p.oldy = p.y; p.x += vx; p.y += vy + 0.5;
                    if (p.y > dummyCanvas.height) { p.y = dummyCanvas.height; p.oldy = p.y + vy * 0.5; }
                    if (p.x > dummyCanvas.width) { p.x = dummyCanvas.width; p.oldx = p.x + vx * 0.5; }
                    if (p.x < 0) { p.x = 0; p.oldx = p.x + vx * 0.5; }
                }
            });

            for (let k = 0; k < 5; k++) {
                sticks.forEach(s => {
                    const dx = s.p1.x - s.p0.x; const dy = s.p1.y - s.p0.y;
                    const dist = Math.sqrt(dx * dx + dy * dy); const diff = s.length - dist;
                    const offX = (dx / dist) * diff * 0.5; const offY = (dy / dist) * diff * 0.5;
                    if (!s.p0.pinned && s.p0 !== draggingPoint) { s.p0.x -= offX; s.p0.y -= offY; }
                    if (!s.p1.pinned && s.p1 !== draggingPoint) { s.p1.x += offX; s.p1.y += offY; }
                });
            }

            ctxDummy.beginPath();
            sticks.forEach(s => { ctxDummy.moveTo(s.p0.x, s.p0.y); ctxDummy.lineTo(s.p1.x, s.p1.y); });
            ctxDummy.strokeStyle = 'black'; ctxDummy.lineWidth = 6; ctxDummy.lineCap = 'round'; ctxDummy.stroke();

            ctxDummy.beginPath();
            ctxDummy.arc(points[0].x, points[0].y, 18, 0, Math.PI * 2);
            ctxDummy.fillStyle = '#E61919'; ctxDummy.fill(); ctxDummy.stroke();

            animationFrames['dummy'] = requestAnimationFrame(updateDummy);
        }

        // --- TOOL: SHOUT (Immersive Audio Visualizer) ---
        let shoutCanvas, ctxShout, shoutWords = [], shoutScore = 0;
        let recognition, audioCtx, analyser, source;
        const shoutVocab = ["I AM ENOUGH", "I RELEASE THIS PAIN", "NO MORE DOUBT", "I CHOOSE ME", "I AM STRONG", "LET IT GO", "THIS IS MY TIME", "I AM FREE"];
        let micStream = null;
        let visualizerRotation = 0;

        function initShout() {
            shoutCanvas = document.getElementById('shout-canvas');
            ctxShout = shoutCanvas.getContext('2d');
            resizeCanvas(shoutCanvas);

            shoutWords = [];
            shoutScore = 0;
            shoutVolume = 0;
            visualizerRotation = 0;

            document.getElementById('shout-score').innerText = '0';
            document.getElementById('shout-gameover').classList.add('hidden');

            const fallback = document.getElementById('shout-fallback');
            const input = document.getElementById('shout-input');
            const micStatus = document.getElementById('mic-status-text');
            const micDot = document.getElementById('mic-status-dot');
            input.value = '';

            // Speech Rec
            const SpeechRec = window.SpeechRecognition || window.webkitSpeechRecognition;
            if (SpeechRec) {
                recognition = new SpeechRec();
                recognition.continuous = true;
                recognition.lang = 'en-US';
                recognition.interimResults = false;

                recognition.onstart = () => {
                    micDot.className = 'w-3 h-3 rounded-full bg-red-600 mic-pulse';
                    micStatus.innerText = "MIC ACTIVE";
                    fallback.classList.add('hidden');
                };

                recognition.onend = () => {
                    if (currentMode === 'shout') try { recognition.start(); } catch (e) { }
                };

                recognition.onresult = (e) => {
                    const last = e.results.length - 1;
                    const transcript = e.results[last][0].transcript.trim().toUpperCase();
                    const heardEl = document.getElementById('heard-text');
                    document.getElementById('heard-value').innerText = transcript;
                    heardEl.classList.remove('hidden');
                    setTimeout(() => heardEl.classList.add('hidden'), 2000);
                    destroyWord(transcript);
                };
                try { recognition.start(); } catch (e) { }
            } else {
                micStatus.innerText = "NO SPEECH API";
                fallback.classList.remove('hidden');
            }

            // Audio Analysis
            if (navigator.mediaDevices && navigator.mediaDevices.getUserMedia) {
                navigator.mediaDevices.getUserMedia({ audio: true })
                    .then(stream => {
                        micStream = stream;
                        audioCtx = new (window.AudioContext || window.webkitAudioContext)();
                        analyser = audioCtx.createAnalyser();
                        source = audioCtx.createMediaStreamSource(stream);
                        source.connect(analyser);
                        analyser.fftSize = 512;
                        audioDataArray = new Uint8Array(analyser.frequencyBinCount);
                    })
                    .catch(err => {
                        micStatus.innerText = "NO MIC AUDIO";
                        fallback.classList.remove('hidden');
                    });
            }
            input.oninput = (e) => {
                const val = e.target.value.toUpperCase();
                if (destroyWord(val)) e.target.value = '';
            };
            animateShout();
        }

        function stopShoutTools() {
            if (recognition) recognition.stop();
            if (micStream) micStream.getTracks().forEach(track => track.stop());
            if (audioCtx) audioCtx.close();
        }

        function destroyRandomWord() {
            if (shoutWords.length > 0) {
                shoutWords.sort((a, b) => b.y - a.y);
                const target = shoutWords[0];
                destroyWord(target.text);
            }
        }

        function destroyWord(txt) {
            const idx = shoutWords.findIndex(w => txt.includes(w.text));
            if (idx !== -1) {
                shoutWords.splice(idx, 1);
                shoutScore += 100;
                document.getElementById('shout-score').innerText = shoutScore;
                const el = document.createElement('div');
                el.className = 'absolute inset-0 bg-red-500 opacity-20 pointer-events-none';
                document.getElementById('shout').appendChild(el);
                setTimeout(() => el.remove(), 100);
                return true;
            }
            return false;
        }

        function drawAudioVisualizer() {
            if (!analyser) return;
            analyser.getByteFrequencyData(audioDataArray);

            const w = shoutCanvas.width;
            const h = shoutCanvas.height;
            const cx = w / 2;
            const cy = h / 2;
            const radius = 100;

            // Background pulse
            let sum = 0;
            for (let i = 0; i < audioDataArray.length; i++) sum += audioDataArray[i];
            const avg = sum / audioDataArray.length;

            // Shout detection trigger
            if (avg > 50 && Math.random() < 0.1) destroyRandomWord();

            ctxShout.fillStyle = `rgba(0, 0, 0, 0.1)`; // Trails
            ctxShout.fillRect(0, 0, w, h);

            ctxShout.save();
            ctxShout.translate(cx, cy);
            visualizerRotation += 0.005 + (avg * 0.0001);
            ctxShout.rotate(visualizerRotation);

            const bars = 60;
            const step = (Math.PI * 2) / bars;

            for (let i = 0; i < bars; i++) {
                const val = audioDataArray[i % audioDataArray.length]; // Use low freqs mostly
                const barHeight = (val / 255) * (h / 2);

                // Color mapping based on pitch/intensity
                const r = val + 50;
                const g = 0;
                const b = 255 - val;

                ctxShout.fillStyle = `rgb(${r},${g},${b})`;
                ctxShout.save();
                ctxShout.rotate(i * step);

                // Draw expansive bars
                ctxShout.beginPath();
                ctxShout.moveTo(0, radius);
                ctxShout.lineTo(5, radius + barHeight);
                ctxShout.lineTo(-5, radius + barHeight);
                ctxShout.fill();

                // Draw secondary "electric" sparks for high freq
                if (i > 40 && val > 100) {
                    ctxShout.strokeStyle = 'white';
                    ctxShout.beginPath();
                    ctxShout.moveTo(0, radius + barHeight);
                    ctxShout.lineTo((Math.random() - 0.5) * 20, radius + barHeight + 20);
                    ctxShout.stroke();
                }

                ctxShout.restore();
            }
            ctxShout.restore();
        }

        function animateShout() {
            if (currentMode !== 'shout') return;

            // Draw Visualizer Background First
            drawAudioVisualizer();

            // Word Layer
            if (Math.random() < 0.01) {
                shoutWords.push({
                    text: shoutVocab[Math.floor(Math.random() * shoutVocab.length)],
                    x: Math.random() * (shoutCanvas.width - 400) + 200,
                    y: -50,
                    speed: Math.random() * 1.5 + 1.0
                });
            }

            ctxShout.font = 'bold 40px Anton';
            ctxShout.textAlign = 'center';

            for (let i = shoutWords.length - 1; i >= 0; i--) {
                let w = shoutWords[i];
                w.y += w.speed;
                ctxShout.fillStyle = 'white'; // White text on dark background
                ctxShout.fillText(w.text, w.x, w.y);
                if (w.y > shoutCanvas.height) {
                    gameOverShout();
                    return;
                }
            }
            animationFrames['shout'] = requestAnimationFrame(animateShout);
        }

        function gameOverShout() {
            stopShoutTools();
            document.getElementById('shout-final-score').innerText = shoutScore;
            document.getElementById('shout-gameover').classList.remove('hidden');
            cancelAnimationFrame(animationFrames['shout']);
        }
        function resetShout() { initShout(); }


        // --- TOOL: MIRROR (Flux Mode) ---
        let mirrorVideo, mirrorCanvas, ctxMirror, mirrorStream;
        let mirrorParticles = [];
        let prevFrameData = null;

        function initMirror() {
            mirrorVideo = document.getElementById('mirror-video');
            mirrorCanvas = document.getElementById('mirror-canvas');
            ctxMirror = mirrorCanvas.getContext('2d');
            resizeCanvas(mirrorCanvas);

            mirrorParticles = [];
            prevFrameData = null;

            navigator.mediaDevices.getUserMedia({ video: true })
                .then(stream => {
                    mirrorStream = stream;
                    mirrorVideo.srcObject = stream;
                    mirrorVideo.play();
                    animateMirror();
                })
                .catch(err => {
                    console.error("Camera Error", err);
                    document.getElementById('camera-error').classList.remove('hidden');
                });
        }

        function stopMirrorTools() {
            if (mirrorStream) {
                mirrorStream.getTracks().forEach(track => track.stop());
            }
        }

        function animateMirror() {
            if (currentMode !== 'mirror') return;

            const w = mirrorCanvas.width;
            const h = mirrorCanvas.height;

            // 1. Draw current video frame to background logic
            ctxMirror.drawImage(mirrorVideo, 0, 0, w, h);
            const frame = ctxMirror.getImageData(0, 0, w, h);
            const data = frame.data;

            // 2. Trail Effect (Black Fade)
            // Use 'source-over' to obscure previous frames slowly
            ctxMirror.globalCompositeOperation = 'source-over';
            ctxMirror.globalAlpha = 0.15;
            ctxMirror.fillStyle = '#050000'; // Very dark red/black
            ctxMirror.fillRect(0, 0, w, h);

            // 3. Motion Detection & Heat Map Construction
            if (!prevFrameData) {
                prevFrameData = new Uint8ClampedArray(data.length);
                for (let i = 0; i < data.length; i++) prevFrameData[i] = data[i];
            }

            const outputFrame = ctxMirror.createImageData(w, h);
            const outData = outputFrame.data;

            // Optimization: Stride 4 for performance + stylistic blockiness
            for (let i = 0; i < data.length; i += 4) {
                const r = data[i]; const g = data[i + 1]; const b = data[i + 2];
                const avg = (r + g + b) / 3;

                const pr = prevFrameData[i]; const pg = prevFrameData[i + 1]; const pb = prevFrameData[i + 2];
                const pAvg = (pr + pg + pb) / 3;

                const diff = Math.abs(avg - pAvg);

                // Calculate Heat: Base brightness + Motion boost
                let heat = avg * 0.3 + (diff * 5);
                if (heat > 255) heat = 255;

                // Heatmap Color Gradient (Cold -> Hot)
                if (heat < 25) {
                    // Transparent for low heat (shows trails)
                    outData[i] = 0; outData[i + 1] = 0; outData[i + 2] = 0; outData[i + 3] = 0;
                } else {
                    let ro, go, bo;
                    if (heat < 100) {
                        // Purple/Blue (Cold/Static)
                        ro = heat * 0.5; go = 0; bo = heat * 1.5;
                    } else if (heat < 180) {
                        // Red (Warming Up)
                        ro = heat * 1.4; go = (heat - 100) * 0.5; bo = 0;
                    } else {
                        // Yellow/White (Hot/Motion)
                        ro = 255; go = (heat - 100) * 1.5; bo = (heat - 180) * 3;
                    }

                    outData[i] = Math.min(255, ro);
                    outData[i + 1] = Math.min(255, go);
                    outData[i + 2] = Math.min(255, bo);
                    outData[i + 3] = 255; // Alpha
                }

                // Particle Spawning
                if (diff > 35 && Math.random() < 0.08) {
                    const pixelIdx = i / 4;
                    const px = pixelIdx % w;
                    const py = Math.floor(pixelIdx / w);

                    // Create Sparks
                    mirrorParticles.push({
                        x: px, y: py,
                        vx: (Math.random() - 0.5) * 12,
                        vy: (Math.random() - 0.5) * 12 - 2, // Slight rise
                        life: 1.0,
                        size: Math.random() * 3 + 1,
                        color: heat > 200 ? '#FFFFFF' : (heat > 150 ? '#FFD700' : '#FF4500')
                    });
                }

                // Update previous frame buffer
                prevFrameData[i] = r; prevFrameData[i + 1] = g; prevFrameData[i + 2] = b;
            }

            // Draw the Heatmap
            const tempCanvas = document.createElement('canvas');
            tempCanvas.width = w; tempCanvas.height = h;
            const tempCtx = tempCanvas.getContext('2d');
            tempCtx.putImageData(outputFrame, 0, 0);

            ctxMirror.globalAlpha = 0.9;
            ctxMirror.globalCompositeOperation = 'screen'; // Make it glow against dark background
            ctxMirror.drawImage(tempCanvas, 0, 0);

            // Draw Particles
            ctxMirror.globalCompositeOperation = 'lighter'; // Additive blending for sparks
            for (let i = mirrorParticles.length - 1; i >= 0; i--) {
                let p = mirrorParticles[i];
                p.x += p.vx;
                p.y += p.vy;
                p.life -= 0.05;
                p.vx *= 0.9; // Friction
                p.vy *= 0.9;

                if (p.life <= 0) {
                    mirrorParticles.splice(i, 1);
                } else {
                    ctxMirror.fillStyle = p.color;
                    ctxMirror.globalAlpha = p.life;
                    ctxMirror.beginPath();
                    ctxMirror.arc(p.x, p.y, p.size * p.life, 0, Math.PI * 2);
                    ctxMirror.fill();
                }
            }

            // Reset context settings
            ctxMirror.globalCompositeOperation = 'source-over';
            ctxMirror.globalAlpha = 1.0;

            animationFrames['mirror'] = requestAnimationFrame(animateMirror);
        }

        // Global Resize
        window.addEventListener('resize', () => {
            const canvases = document.querySelectorAll('canvas');
            canvases.forEach(c => resizeCanvas(c));
        });

    </script>
</body>

</html>